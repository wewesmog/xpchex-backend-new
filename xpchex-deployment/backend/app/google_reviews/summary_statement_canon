
# google_reviews/canonization.py

import os
import sys
from app.models.canonization_models import ExistingStatement, CanonizationRequest
from typing import List, Tuple, Dict, Optional
from datetime import date, datetime, timedelta
from app.agents.canonize_statement import canonize_statement_node
from app.models.canonization_models import CanonizationLLMResponse
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, 
                   format='%(message)s')  # Simplified format
logger = logging.getLogger(__name__)

# Suppress other loggers
logging.getLogger('QueryStateLogger').setLevel(logging.WARNING)
logging.getLogger('urllib3').setLevel(logging.WARNING)
logging.getLogger('asyncio').setLevel(logging.WARNING)
logging.getLogger('httpx').setLevel(logging.WARNING)  # OpenRouter uses httpx
logging.getLogger('openai').setLevel(logging.WARNING)  # Suppress OpenAI client logs

# Add the backend directory to the Python path
backend_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
sys.path.append(backend_dir)

from app.shared_services.db import get_postgres_connection

def get_canon_statements()
  # Get canon statements and their canonical ids
        conn = get_postgres_connection()
        cursor = conn.cursor()
        
        try:
            # Get reviews for the day where canonization hasn't been done
            cursor.execute("""
                SELECT  canonical_id ,
                        array_agg(statement) as statements
                FROM canonical_statements 
                GROUP BY canonical_id
                ORDER BY canonical_id
          
             
            """)
            
            canon_statements = cursor.fetchall()
            return canon_statements
        except Exception as e:
            logger.error(f"Error getting canon statements: {e}")
            return []
        
def get_summary_statements():
     canon_statements = get_canon_statements()
     for canon_id, statements in canon_statements:
        print(f"\nCanonical ID: {canon_id}")
        for statement in statements:
            if 'summary' in statement.lower():
                print(f"  - {statement}")
     return None


if __name__ == "__main__":
    get_summary_statements()